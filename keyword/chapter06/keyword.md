- 지연로딩과 즉시로딩의 차이:
    - 즉시로딩: 실제 DB에서 조인된 테이블들을 '즉시'한 번에 조회하여, 하나의 쿼리로 가져온다.
    `@ManyToOne(fetch=FetchType.EAGER)`
     형태로 사용한다.
    - 지연로딩: DB가 아닌 프록시에서 데이터를 가져온다.조인되는 테이블들을 각각 분리하여, 쿼리의 주체인 테이블만 DB에서, 나머지는 프록시를 조회한다. 나머지 테이블을 굳이 조회할 필요가 없는 경우 분리하여 조회하는 방법을 사용한다.
    `@ManyToOne(fetch=FetchType.LAZY)`
    형태로 사용한다.

- Fetch Join: JAP에서 연관된 엔티티를 함께 조회할 때 사용되는 방법이다. SQL의 JOIN문을 활용하여 관련된 엔티티를 한 번의 쿼리로 가져온다. N+1의 문제를 해결하고 성능을 향상시키는데 사용된다. Fetch Join을 적용하면, 메인 엔티티와 연관된 엔티티가 동시에 로딩되어 Hibernate가 더 적은 쿼리를 실행하는 효과가 있고, 관련된 데이터를 한번에 가져오기 때문에 데이터베이스 호출 횟수도 줄어들게 된다. 사용하는 방법은 JPQL에서 `JOIN FETCH` 구문을 통해 구현할 수 있다.

- `@EntityGraph`: JPA에서 특정 엔티티를 조회할 때, 관련된 엔티티를 함께 로딩하기 위해 사용하는 어노테이션이다. 연관관계가 있는 엔티티를 조회할 경우 지연 로딩으로 설정이 되어 있으면 연관관계에 종속된 엔티티는 쿼리 실행을 할 때 select 되지 않고 proxy객체를 만들어 엔티티가 적용시킨다. 그 후 해당 proxy객체를 호출할 때 마다 그때 그때 select 쿼리가 실행된다.
Fetch Join과 유사한 기능을 하지만, 좀 더 유연하게 쿼리를 조정할 수 있다. 마찬가지로 N+1문제를 해결할 수 있는 방법이다. 필요할 때만 특정 필드나 연관된 엔티티를 로딩할 수 있도록 설정할 수 있다. 메서드의 매개변수로 `EntityGraph`를 지정하여 사용하고 이를 통해 데이터만 효율적으로 가져오고, 불필요한 데이터의 로딩을 피할 수 있다. 

- JPQL:SQL을 추상화한 객체 지향 쿼리언어이다. 테이블을 대상으로 쿼리하는 SQL과 달리 엔티티 객체를 대상으로 쿼리한다.객체 지향적인 특성을 반영한 쿼리를 날릴 수 있게 하여 5주차에서 다루었던 JAVA와 RDB의 패러다임 불일치를 해결할 수 있다.
특정 데이터베이스 SQL에 의존하지 않는 것이 장점이다. SQL과 문법이 유사하며, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN을 지원한다. JPQL은 결국 SQL로 변환된다. 문제점은 기본 문자열로 작성되기 때문에 컴파일 시 에러를 발생하지 않는다. 문제가 있음에도 불구하고 정상적으로 작동할 수 있다. 동적으로 쿼리 언어를 작성하는 데 효율적이지 못하다.
사용방법은 다음과 같다.
    - NativeSQL과 병행 사용이 가능하며, 트랜잭션 관리, 엔티티 작업 관리에 탁월한 EntityManager 인터페이스
    - 간결함과 일관성 유지에 탁월한 repository 인터페이스
2가지 방식이 있다. 더 일반적으로는 2번 방법을 사용한다.
repository 인터페이스를 활용하는 방식에도 2가지가 있다.
    1. 메서드 이름으로 쿼리를 자동 생성
    2. `@Query` 어노테이션으로 JQPL을 직접 작성하는 방법



- QueryDSL: 타입 안전성을 보장하는 자바 기반의 쿼리 빌더 라이브러리다. 코드 기반의 쿼리 빌더를 제공하기 때문에 컴파일 시점에 쿼리 오류를 잡을 수 있고, 동적 쿼리 작성이 편하다. 메서드 체이닝을 통한 복잡한 쿼리 작성에 유리하다.
(동적 쿼리란, 실행 시점에 쿼리의 일부가 변경될 수 있는 쿼리)
QueryDSL을 사용하려면 Q 클래스를 자동으로 생성하기 위해 설정이 필요하다. build.gradle 파일에 플러그인과 종속성을 명시해준다.